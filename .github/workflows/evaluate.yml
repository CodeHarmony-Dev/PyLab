name: 测评学习者代码

on:
  pull_request_target:
    branches: [ submit ]
    types: [opened, synchronize, reopened]

# 添加权限配置
permissions:
  contents: write    # 允许修改仓库内容（用于合并PR）
  pull-requests: write    # 允许更新PR状态和评论PR
  issues: write    # 允许评论issues

jobs:
  validate-submission:
    runs-on: ubuntu-latest
    name: 验证提交格式
    outputs:
      paths: ${{ steps.find-changes.outputs.paths }}
      username: ${{ steps.extract-info.outputs.username }}
      valid: ${{ steps.validate-path.outputs.valid }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: 查找更改的文件
        id: find-changes
        run: |
          # 使用 GitHub API 获取 PR 中更改的文件
          PR_FILES=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files" | \
            jq -r '.[].filename')
          
          echo "Changed files via API: $PR_FILES"
          
          # 检查是否只有submit目录下的文件被修改
          VALID_CHANGES=true
          PATHS=""
          
          for file in $PR_FILES; do
            # 检查文件是否在submit目录下
            if [[ ! $file =~ ^submit/ ]]; then
              VALID_CHANGES=false
              echo "错误: 文件 $file 不在submit目录下"
              continue
            fi
            
            # 提取用户名和实验编号
            if [[ $file =~ ^submit/([^/]+)/lab([0-9]+)/ ]]; then
              USERNAME="${BASH_REMATCH[1]}"
              LAB_NUM="${BASH_REMATCH[2]}"
              LAB_PATH="$USERNAME/lab$LAB_NUM"
              
              # 添加到路径列表，避免重复
              if [[ ! $PATHS =~ $LAB_PATH ]]; then
                if [[ -z "$PATHS" ]]; then
                  PATHS="$LAB_PATH"
                else
                  PATHS="$PATHS $LAB_PATH"
                fi
              fi
            else
              VALID_CHANGES=false
              echo "错误: 文件 $file 不符合提交格式"
            fi
          done
          
          # 输出结果
          echo "valid=$VALID_CHANGES" >> $GITHUB_OUTPUT
          echo "paths=$PATHS" >> $GITHUB_OUTPUT
          
      - name: 提取用户信息
        id: extract-info
        run: |
          # 从paths中提取用户名
          PATHS="${{ steps.find-changes.outputs.paths }}"
          if [[ $PATHS =~ ^([^/]+)/ ]]; then
            USERNAME="${BASH_REMATCH[1]}"
            echo "username=$USERNAME" >> $GITHUB_OUTPUT
          else
            echo "username=unknown" >> $GITHUB_OUTPUT
          fi
          
      - name: 验证用户名匹配
        id: validate-username
        run: |
          PR_USERNAME="${{ github.event.pull_request.user.login }}"
          SUBMISSION_USERNAME="${{ steps.extract-info.outputs.username }}"
          
          echo "PR用户名: $PR_USERNAME"
          echo "提交路径用户名: $SUBMISSION_USERNAME"
          
          if [[ "$PR_USERNAME" == "$SUBMISSION_USERNAME" ]]; then
            echo "用户名匹配验证通过"
            echo "username_valid=true" >> $GITHUB_OUTPUT
          else
            echo "错误: PR用户名与提交路径用户名不匹配"
            echo "username_valid=false" >> $GITHUB_OUTPUT
          fi
          
      - name: 验证路径格式
        id: validate-path
        run: |
          VALID="${{ steps.find-changes.outputs.valid }}"
          USERNAME_VALID="${{ steps.validate-username.outputs.username_valid }}"
          
          if [[ "$VALID" == "true" && "$USERNAME_VALID" == "true" && ! -z "${{ steps.find-changes.outputs.paths }}" ]]; then
            echo "valid=true" >> $GITHUB_OUTPUT
          else
            echo "valid=false" >> $GITHUB_OUTPUT
          fi
          
      - name: 提交格式错误反馈
        if: steps.validate-path.outputs.valid != 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let errorMessage = '❌ 提交格式错误！';
            
            if ('${{ steps.validate-username.outputs.username_valid }}' === 'false') {
              errorMessage += '\n- PR用户名与提交路径用户名不匹配。请确保提交的路径中的用户名与您的GitHub用户名一致。';
            }
            
            errorMessage += '\n- 请确保只修改 `/submit/[您的GitHub用户名]/lab[实验编号]/` 目录下的文件。';
            errorMessage += '\n\n请修正以上问题后重新提交。';
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: errorMessage
            });

  evaluate-code:
    needs: validate-submission
    if: needs.validate-submission.outputs.valid == 'true'
    runs-on: ubuntu-latest
    name: 测评代码
    steps:
      - name: 检出代码
        uses: actions/checkout@v3
        
      - name: 设置Python环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: 安装依赖
        run: |
          python -m pip install --upgrade pip
          
          # 安装根目录下的依赖
          if [ -f "requirements.txt" ]; then
            echo "安装根目录下的依赖..."
            python -m pip install -r requirements.txt
          fi
          
          # 安装实验依赖
          for LAB_PATH in ${{ needs.validate-submission.outputs.paths }}; do
            if [[ $LAB_PATH =~ ([^/]+)/lab([0-9]+) ]]; then
              LAB_NUM="${BASH_REMATCH[2]}"
              # 检查并安装实验的依赖
              REQ_FILE="code/lab${LAB_NUM}/requirements.txt"
              if [ -f "$REQ_FILE" ]; then
                echo "安装实验 ${LAB_NUM} 的依赖..."
                python -m pip install -r "$REQ_FILE"
              fi
              
              # 检查并安装学习者的依赖
              SUBMIT_REQ="submit/$LAB_PATH/requirements.txt"
              if [ -f "$SUBMIT_REQ" ]; then
                echo "安装学习者 ${LAB_PATH} 的依赖..."
                python -m pip install -r "$SUBMIT_REQ"
              fi
            fi
          done
          
      - name: 编译学习者代码
        run: |
          # 获取提交的路径列表
          PATHS="${{ needs.validate-submission.outputs.paths }}"
          USERNAME="${{ needs.validate-submission.outputs.username }}"
          
          for LAB_PATH in $PATHS; do
            if [[ $LAB_PATH =~ ([^/]+)/lab([0-9]+) ]]; then
              LAB_NUM="${BASH_REMATCH[2]}"
              SUBMIT_DIR="submit/$LAB_PATH"
              
              echo "处理 $SUBMIT_DIR 中的Python文件..."
              
              # 复制setup.py到提交目录
              cp evaluate/_setup.py "$SUBMIT_DIR/setup.py"
              
              # 进入目录并运行编译
              (cd "$SUBMIT_DIR" && python setup.py build_ext --inplace)
              
              # 清理临时文件
              rm -f "$SUBMIT_DIR/setup.py"
              rm -rf "$SUBMIT_DIR/build"
              # 删除生成的 .c 文件
              find "$SUBMIT_DIR" -name "*.c" -delete
            fi
          done
          
      - name: 运行测评
        id: evaluate
        run: |
          # 获取提交的路径列表
          PATHS="${{ needs.validate-submission.outputs.paths }}"
          
          # 构建测评命令参数
          PATH_ARGS=""
          for LAB_PATH in $PATHS; do
            if [[ -z "$PATH_ARGS" ]]; then
              PATH_ARGS="$LAB_PATH"
            else
              PATH_ARGS="$PATH_ARGS $LAB_PATH"
            fi
          done
          
          # 添加当前目录到 PYTHONPATH，确保可以找到 evaluate 目录中的模块
          export PYTHONPATH=$PYTHONPATH:$(pwd)/evaluate
          
          # 运行测评脚本，一次性测评所有路径
          RESULT=$(python -m evaluate.main --path $PATH_ARGS)
          EXIT_CODE=$?
          
          # 保存结果和退出码
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          echo "details<<EOF" >> $GITHUB_OUTPUT
          echo -e "$RESULT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: 提交测评结果
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const details = `${{ steps.evaluate.outputs.details }}`;
            const exitCode = parseInt('${{ steps.evaluate.outputs.exit_code }}');
            
            let commentBody = '';
            let passed = false;
            
            try {
              console.log("开始处理测评结果...");
              console.log(`退出码: ${exitCode}`);
              
              if (exitCode !== 0) {
                commentBody = `❌ **测评脚本执行失败**，退出码: ${exitCode}\n\n这可能是由系统问题导致的，而非您代码的问题。请联系仓库维护者寻求帮助。`;
              } else {
                try {
                  const resultObj = JSON.parse(details);
                  console.log("JSON解析成功");
                  
                  // 检查是否有顶层错误
                  if (resultObj.error) {
                    commentBody = `❌ **测评过程发生错误！**\n\n这可能是测评系统的问题，请联系仓库维护者寻求帮助。`;
                  } else {
                    // 检查每个实验的passed字段和table_update_error字段
                    const allPassed = resultObj.every(item => item.passed === true);
                    const hasTableError = resultObj.some(item => item.table_update_error);
                    
                    passed = allPassed && !hasTableError;
                    
                    if (passed) {
                      commentBody = '✅ **测评通过！** 恭喜您成功完成了本次实验任务！';
                    } else if (hasTableError) {
                      commentBody = '❌ **测评未通过 - 成绩表更新错误**\n\n在更新成绩表过程中发生错误，这可能是系统问题。请联系仓库维护者寻求帮助。';
                    } else {
                      // 创建用户友好的错误报告，不展示完整details
                      let failedLabs = [];
                      resultObj.forEach(lab => {
                        if (!lab.passed) {
                          let labSummary = `**实验 ${lab.lab_num}**: `;
                          
                          // 计算通过和失败的任务数
                          let passedTasks = 0;
                          let failedTasks = 0;
                          let hasError = false;
                          
                          Object.values(lab.tasks).forEach(task => {
                            if (task.returncode === 0) {
                              passedTasks++;
                            } else {
                              failedTasks++;
                              if (task.error) hasError = true;
                            }
                          });
                          
                          labSummary += `通过 ${passedTasks} 个任务，失败 ${failedTasks} 个任务`;
                          if (hasError) labSummary += "（代码执行过程中出现错误）";
                          
                          failedLabs.push(labSummary);
                        }
                      });
                      
                      commentBody = '❌ **测评未通过**\n\n' + failedLabs.join('\n') + '\n\n请检查您的代码并解决问题。修改后重新提交PR即可重新触发测评。';
                    }
                  }
                } catch (parseError) {
                  console.error(`JSON解析失败: ${parseError.message}`);
                  console.error(`原始数据: ${details}`);
                  commentBody = `❌ **测评结果解析失败！**\n\n这是测评系统内部问题，请联系仓库维护者寻求帮助。`;
                }
              }
            } catch (e) {
              console.error(`处理测评结果时发生错误: ${e.message}`);
              console.error(e.stack);
              commentBody = `❌ **测评结果处理失败！**\n\n这是测评系统内部问题，请联系仓库维护者寻求帮助。`;
            }
            
            console.log(`准备提交评论: ${commentBody}`);
            console.log(`Token权限检查: 正在尝试访问PR #${context.issue.number}`);
            
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              console.log("评论创建成功");
              
              if (passed) {
                console.log("测试通过，尝试合并PR");
                await github.rest.pulls.update({
                  pull_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'closed',
                  merge_method: 'merge'
                });
                console.log("PR合并成功");
              }
            } catch (apiError) {
              console.error(`API调用失败: ${apiError.message}`);
              console.error(`状态码: ${apiError.status}`);
              console.error(`响应数据: ${JSON.stringify(apiError.response?.data || {})}`);
              core.setFailed(`GitHub API调用失败: ${apiError.message}`);
            }